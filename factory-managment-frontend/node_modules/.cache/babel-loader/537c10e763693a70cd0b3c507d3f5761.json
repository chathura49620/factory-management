{"ast":null,"code":"// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { range } from 'd3-array';\nimport { scaleLinear } from 'd3-scale';\nexport var ORIENTATION = {\n  TOP: 'top',\n  LEFT: 'left',\n  RIGHT: 'right',\n  BOTTOM: 'bottom',\n  VERTICAL: 'vertical',\n  HORIZONTAL: 'horizontal'\n};\nexport var DIRECTION = {\n  VERTICAL: 'vertical',\n  HORIZONTAL: 'horizontal'\n};\n/**\r\n * Get total amount of ticks from a given size in pixels.\r\n * @param {number} size Size of the axis in pixels.\r\n * @returns {number} Total amount of ticks.\r\n */\n\nexport function getTicksTotalFromSize(size) {\n  if (size < 700) {\n    if (size > 300) {\n      return 10;\n    }\n\n    return 5;\n  }\n\n  return 20;\n}\n/**\r\n * Get the tick values from a given d3 scale.\r\n * @param {d3.scale} scale Scale function.\r\n * @param {number} tickTotal Total number of ticks\r\n * @param {Array} tickValues Array of tick values if they exist.\r\n * @returns {Array} Array of tick values.\r\n */\n\nexport function getTickValues(scale, tickTotal, tickValues) {\n  return !tickValues ? scale.ticks ? scale.ticks(tickTotal) : scale.domain() : tickValues;\n}\n/**\r\n * Generate a description of a decorative axis in terms of a linear equation\r\n * y = slope * x + offset in coordinates\r\n * @param {Object} axisStart Object of format {x, y} describing in coordinates\r\n * the start position of the decorative axis\r\n * @param {Object} axisEnd Object of format {x, y} describing in coordinates\r\n * the start position of the decorative axis\r\n * @returns {Number} Object describing each the line in coordinates\r\n */\n\nexport function generateFit(axisStart, axisEnd) {\n  // address the special case when the slope is infinite\n  if (axisStart.x === axisEnd.x) {\n    return {\n      left: axisStart.y,\n      right: axisEnd.y,\n      slope: 0,\n      offset: axisStart.x\n    };\n  }\n\n  var slope = (axisStart.y - axisEnd.y) / (axisStart.x - axisEnd.x);\n  return {\n    left: axisStart.x,\n    right: axisEnd.x,\n    // generate the linear projection of the axis direction\n    slope: slope,\n    offset: axisStart.y - slope * axisStart.x\n  };\n}\n/**\r\n * Generate a description of a decorative axis in terms of a linear equation\r\n * y = slope * x + offset in coordinates\r\n * @param props\r\n * props.@param {Object} axisStart Object of format {x, y} describing in coordinates\r\n * the start position of the decorative axis\r\n * props.@param {Object} axisEnd Object of format {x, y} describing in coordinates\r\n * the start position of the decorative axis\r\n * props.@param {Number} numberOfTicks The number of ticks on the axis\r\n * props.@param {Array.Numbers} axisDomain The values to be interpolated across for the axis\r\n * @returns {Number} Object describing the slope and the specific coordinates of the points\r\n */\n\nexport function generatePoints(_ref) {\n  var axisStart = _ref.axisStart,\n      axisEnd = _ref.axisEnd,\n      numberOfTicks = _ref.numberOfTicks,\n      axisDomain = _ref.axisDomain;\n\n  var _generateFit = generateFit(axisStart, axisEnd),\n      left = _generateFit.left,\n      right = _generateFit.right,\n      slope = _generateFit.slope,\n      offset = _generateFit.offset; // construct a linear band of points, then map them\n\n\n  var pointSlope = (right - left) / numberOfTicks;\n  var axisScale = scaleLinear().domain([left, right]).range(axisDomain);\n  var slopeVertical = axisStart.x === axisEnd.x;\n  return {\n    slope: slopeVertical ? Infinity : slope,\n    points: range(left, right + pointSlope, pointSlope).map(function (val) {\n      if (slopeVertical) {\n        return {\n          y: val,\n          x: slope * val + offset,\n          text: axisScale(val)\n        };\n      }\n\n      return {\n        x: val,\n        y: slope * val + offset,\n        text: axisScale(val)\n      };\n    }).slice(0, numberOfTicks + 1)\n  };\n}\n/**\r\n * Compute the angle (in radians) of a decorative axis\r\n * @param {Object} axisStart Object of format {x, y} describing in coordinates\r\n * the start position of the decorative axis\r\n * @param {Object} axisEnd Object of format {x, y} describing in coordinates\r\n * the start position of the decorative axis\r\n * @returns {Number} Angle in radials\r\n */\n\nexport function getAxisAngle(axisStart, axisEnd) {\n  if (axisStart.x === axisEnd.x) {\n    return axisEnd.y > axisStart.y ? Math.PI / 2 : 3 * Math.PI / 2;\n  }\n\n  return Math.atan((axisEnd.y - axisStart.y) / (axisEnd.x - axisStart.x));\n}\nexport default {\n  DIRECTION: DIRECTION,\n  ORIENTATION: ORIENTATION,\n  getTicksTotalFromSize: getTicksTotalFromSize,\n  getTickValues: getTickValues\n};","map":{"version":3,"sources":["C:/Users/thero/OneDrive/Documents/factory-management/factory-management/factory-managment-frontend/node_modules/react-vis/es/utils/axis-utils.js"],"names":["range","scaleLinear","ORIENTATION","TOP","LEFT","RIGHT","BOTTOM","VERTICAL","HORIZONTAL","DIRECTION","getTicksTotalFromSize","size","getTickValues","scale","tickTotal","tickValues","ticks","domain","generateFit","axisStart","axisEnd","x","left","y","right","slope","offset","generatePoints","_ref","numberOfTicks","axisDomain","_generateFit","pointSlope","axisScale","slopeVertical","Infinity","points","map","val","text","slice","getAxisAngle","Math","PI","atan"],"mappings":"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","sourcesContent":["// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE.\r\n\r\nimport { range } from 'd3-array';\r\nimport { scaleLinear } from 'd3-scale';\r\n\r\nexport var ORIENTATION = {\r\n  TOP: 'top',\r\n  LEFT: 'left',\r\n  RIGHT: 'right',\r\n  BOTTOM: 'bottom',\r\n  VERTICAL: 'vertical',\r\n  HORIZONTAL: 'horizontal'\r\n};\r\n\r\nexport var DIRECTION = {\r\n  VERTICAL: 'vertical',\r\n  HORIZONTAL: 'horizontal'\r\n};\r\n\r\n/**\r\n * Get total amount of ticks from a given size in pixels.\r\n * @param {number} size Size of the axis in pixels.\r\n * @returns {number} Total amount of ticks.\r\n */\r\nexport function getTicksTotalFromSize(size) {\r\n  if (size < 700) {\r\n    if (size > 300) {\r\n      return 10;\r\n    }\r\n    return 5;\r\n  }\r\n  return 20;\r\n}\r\n\r\n/**\r\n * Get the tick values from a given d3 scale.\r\n * @param {d3.scale} scale Scale function.\r\n * @param {number} tickTotal Total number of ticks\r\n * @param {Array} tickValues Array of tick values if they exist.\r\n * @returns {Array} Array of tick values.\r\n */\r\nexport function getTickValues(scale, tickTotal, tickValues) {\r\n  return !tickValues ? scale.ticks ? scale.ticks(tickTotal) : scale.domain() : tickValues;\r\n}\r\n\r\n/**\r\n * Generate a description of a decorative axis in terms of a linear equation\r\n * y = slope * x + offset in coordinates\r\n * @param {Object} axisStart Object of format {x, y} describing in coordinates\r\n * the start position of the decorative axis\r\n * @param {Object} axisEnd Object of format {x, y} describing in coordinates\r\n * the start position of the decorative axis\r\n * @returns {Number} Object describing each the line in coordinates\r\n */\r\nexport function generateFit(axisStart, axisEnd) {\r\n  // address the special case when the slope is infinite\r\n  if (axisStart.x === axisEnd.x) {\r\n    return {\r\n      left: axisStart.y,\r\n      right: axisEnd.y,\r\n      slope: 0,\r\n      offset: axisStart.x\r\n    };\r\n  }\r\n  var slope = (axisStart.y - axisEnd.y) / (axisStart.x - axisEnd.x);\r\n  return {\r\n    left: axisStart.x,\r\n    right: axisEnd.x,\r\n    // generate the linear projection of the axis direction\r\n    slope: slope,\r\n    offset: axisStart.y - slope * axisStart.x\r\n  };\r\n}\r\n\r\n/**\r\n * Generate a description of a decorative axis in terms of a linear equation\r\n * y = slope * x + offset in coordinates\r\n * @param props\r\n * props.@param {Object} axisStart Object of format {x, y} describing in coordinates\r\n * the start position of the decorative axis\r\n * props.@param {Object} axisEnd Object of format {x, y} describing in coordinates\r\n * the start position of the decorative axis\r\n * props.@param {Number} numberOfTicks The number of ticks on the axis\r\n * props.@param {Array.Numbers} axisDomain The values to be interpolated across for the axis\r\n * @returns {Number} Object describing the slope and the specific coordinates of the points\r\n */\r\nexport function generatePoints(_ref) {\r\n  var axisStart = _ref.axisStart,\r\n      axisEnd = _ref.axisEnd,\r\n      numberOfTicks = _ref.numberOfTicks,\r\n      axisDomain = _ref.axisDomain;\r\n\r\n  var _generateFit = generateFit(axisStart, axisEnd),\r\n      left = _generateFit.left,\r\n      right = _generateFit.right,\r\n      slope = _generateFit.slope,\r\n      offset = _generateFit.offset;\r\n  // construct a linear band of points, then map them\r\n\r\n\r\n  var pointSlope = (right - left) / numberOfTicks;\r\n  var axisScale = scaleLinear().domain([left, right]).range(axisDomain);\r\n\r\n  var slopeVertical = axisStart.x === axisEnd.x;\r\n  return {\r\n    slope: slopeVertical ? Infinity : slope,\r\n    points: range(left, right + pointSlope, pointSlope).map(function (val) {\r\n      if (slopeVertical) {\r\n        return { y: val, x: slope * val + offset, text: axisScale(val) };\r\n      }\r\n      return { x: val, y: slope * val + offset, text: axisScale(val) };\r\n    }).slice(0, numberOfTicks + 1)\r\n  };\r\n}\r\n\r\n/**\r\n * Compute the angle (in radians) of a decorative axis\r\n * @param {Object} axisStart Object of format {x, y} describing in coordinates\r\n * the start position of the decorative axis\r\n * @param {Object} axisEnd Object of format {x, y} describing in coordinates\r\n * the start position of the decorative axis\r\n * @returns {Number} Angle in radials\r\n */\r\nexport function getAxisAngle(axisStart, axisEnd) {\r\n  if (axisStart.x === axisEnd.x) {\r\n    return axisEnd.y > axisStart.y ? Math.PI / 2 : 3 * Math.PI / 2;\r\n  }\r\n  return Math.atan((axisEnd.y - axisStart.y) / (axisEnd.x - axisStart.x));\r\n}\r\n\r\nexport default {\r\n  DIRECTION: DIRECTION,\r\n  ORIENTATION: ORIENTATION,\r\n  getTicksTotalFromSize: getTicksTotalFromSize,\r\n  getTickValues: getTickValues\r\n};"]},"metadata":{},"sourceType":"module"}