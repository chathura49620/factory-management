{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _SCALE_FUNCTIONS;\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport { scaleLinear, scalePoint, scaleOrdinal, scaleLog, scaleTime, scaleUtc } from 'd3-scale';\nimport { extent } from 'd3-array';\nimport { set } from 'd3-collection';\nimport { hsl } from 'd3-color';\nimport PropTypes from 'prop-types';\nimport { warning } from './react-utils';\nimport { getUniquePropertyValues, addValueToArray } from './data-utils';\n/**\r\n * Linear scale name.\r\n * @type {string}\r\n * @const\r\n */\n\nvar LINEAR_SCALE_TYPE = 'linear';\n/**\r\n * Ordinal scale name.\r\n * @type {string}\r\n * @const\r\n */\n\nvar ORDINAL_SCALE_TYPE = 'ordinal';\n/**\r\n * Category scale.\r\n * @type {string}\r\n * @const\r\n */\n\nvar CATEGORY_SCALE_TYPE = 'category';\n/**\r\n * Literal scale.\r\n * Differs slightly from d3's identity scale in that it does not coerce value\r\n * into numbers, it simply returns exactly what you give it\r\n * @type {string}\r\n * @const\r\n */\n\nvar LITERAL_SCALE_TYPE = 'literal';\n/**\r\n * Log scale name.\r\n * @type {string}\r\n * @const\r\n */\n\nvar LOG_SCALE_TYPE = 'log';\n/**\r\n * Time scale name.\r\n * @type {string}\r\n * @const\r\n */\n\nvar TIME_SCALE_TYPE = 'time';\n/**\r\n * Time UTC scale name.\r\n * @type {string}\r\n * @const\r\n */\n\nvar TIME_UTC_SCALE_TYPE = 'time-utc';\n/**\r\n * Scale functions that are supported in the library.\r\n * @type {Object}\r\n * @const\r\n */\n\nvar SCALE_FUNCTIONS = (_SCALE_FUNCTIONS = {}, _defineProperty(_SCALE_FUNCTIONS, LINEAR_SCALE_TYPE, scaleLinear), _defineProperty(_SCALE_FUNCTIONS, ORDINAL_SCALE_TYPE, scalePoint), _defineProperty(_SCALE_FUNCTIONS, CATEGORY_SCALE_TYPE, scaleOrdinal), _defineProperty(_SCALE_FUNCTIONS, LITERAL_SCALE_TYPE, literalScale), _defineProperty(_SCALE_FUNCTIONS, LOG_SCALE_TYPE, scaleLog), _defineProperty(_SCALE_FUNCTIONS, TIME_SCALE_TYPE, scaleTime), _defineProperty(_SCALE_FUNCTIONS, TIME_UTC_SCALE_TYPE, scaleUtc), _SCALE_FUNCTIONS);\n/**\r\n * Attrs for which a scale can be set up at XYPlot level\r\n * @type {Array}\r\n * @const\r\n */\n\nvar XYPLOT_ATTR = ['color', 'fill', 'opacity', 'stroke'];\n/**\r\n * Title case a given string\r\n * @param {String} str Array of values.\r\n * @returns {String} titlecased string\r\n */\n\nfunction toTitleCase(str) {\n  return '' + str[0].toUpperCase() + str.slice(1);\n}\n/**\r\n * Find the smallest distance between the values on a given scale and return\r\n * the index of the element, where the smallest distance was found.\r\n * It returns the first occurrence of i where\r\n * `scale(value[i]) - scale(value[i - 1])` is minimal\r\n * @param {Array} values Array of values.\r\n * @param {Object} scaleObject Scale object.\r\n * @returns {number} Index of an element where the smallest distance was found.\r\n * @private\r\n */\n\n\nexport function _getSmallestDistanceIndex(values, scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var result = 0;\n\n  if (scaleFn) {\n    var nextValue = void 0;\n    var currentValue = scaleFn(values[0]);\n    var distance = Infinity;\n    var nextDistance = void 0;\n\n    for (var i = 1; i < values.length; i++) {\n      nextValue = scaleFn(values[i]);\n      nextDistance = Math.abs(nextValue - currentValue);\n\n      if (nextDistance < distance) {\n        distance = nextDistance;\n        result = i;\n      }\n\n      currentValue = nextValue;\n    }\n  }\n\n  return result;\n}\n/**\r\n * This is a workaround for issue that ordinal scale\r\n * does not have invert method implemented in d3-scale.\r\n * @param {Object} Ordinal d3-scale object.\r\n * @returns {void}\r\n * @private\r\n */\n\nfunction addInvertFunctionToOrdinalScaleObject(scale) {\n  if (scale.invert) {\n    return;\n  }\n\n  scale.invert = function invert(value) {\n    var _scale$range = scale.range(),\n        _scale$range2 = _slicedToArray(_scale$range, 2),\n        lower = _scale$range2[0],\n        upper = _scale$range2[1];\n\n    var start = Math.min(lower, upper);\n    var stop = Math.max(lower, upper);\n\n    if (value < start + scale.padding() * scale.step()) {\n      return scale.domain()[0];\n    }\n\n    if (value > stop - scale.padding() * scale.step()) {\n      return scale.domain()[scale.domain().length - 1];\n    }\n\n    var index = Math.floor((value - start - scale.padding() * scale.step()) / scale.step());\n    return scale.domain()[index];\n  };\n}\n/**\r\n * Crate a scale function from the scale object.\r\n * @param {Object} scaleObject Scale object.\r\n - scaleObject.domain {Array}\r\n - scaleObject.range {Array}\r\n - scaleObject.type {string}\r\n - scaleObject.attr {string}\r\n * @returns {*} Scale function.\r\n * @private\r\n */\n\n\nexport function getScaleFnFromScaleObject(scaleObject) {\n  if (!scaleObject) {\n    return null;\n  }\n\n  var type = scaleObject.type,\n      domain = scaleObject.domain,\n      range = scaleObject.range;\n  var modDomain = domain[0] === domain[1] ? domain[0] === 0 ? [-1, 0] : [-domain[0], domain[0]] : domain;\n\n  if (type === LITERAL_SCALE_TYPE) {\n    return literalScale(range[0]);\n  }\n\n  var scale = SCALE_FUNCTIONS[type]().domain(modDomain).range(range);\n\n  if (type === ORDINAL_SCALE_TYPE) {\n    scale.padding(0.5);\n    addInvertFunctionToOrdinalScaleObject(scale);\n  }\n\n  return scale;\n}\n/**\r\n * Get the domain from the array of data.\r\n * @param {Array} allData All data.\r\n * @param {function} accessor - accessor for main value.\r\n * @param {function} accessor0 - accessor for the naught value.\r\n * @param {string} type Scale type.\r\n * @returns {Array} Domain.\r\n * @private\r\n */\n\nexport function getDomainByAccessor(allData, accessor, accessor0, type) {\n  var domain = void 0; // Collect both attr and available attr0 values from the array of data.\n\n  var values = allData.reduce(function (data, d) {\n    var value = accessor(d);\n    var value0 = accessor0(d);\n\n    if (_isDefined(value)) {\n      data.push(value);\n    }\n\n    if (_isDefined(value0)) {\n      data.push(value0);\n    }\n\n    return data;\n  }, []);\n\n  if (!values.length) {\n    return [];\n  } // Create proper domain depending on the type of the scale.\n\n\n  if (type !== ORDINAL_SCALE_TYPE && type !== CATEGORY_SCALE_TYPE) {\n    domain = extent(values);\n  } else {\n    domain = set(values).values();\n  }\n\n  return domain;\n}\n/**\r\n * Create custom scale object from the value. When the scale is created from\r\n * this object, it should return the same value all time.\r\n * @param {string} attr Attribute.\r\n * @param {*} value Value.\r\n * @param {string} type - the type of scale being used\r\n * @param {function} accessor - the accessor function\r\n * @param {function} accessor0 - the accessor function for the potential naught value\r\n * @returns {Object} Custom scale object.\r\n * @private\r\n */\n\nfunction _createScaleObjectForValue(attr, value, type, accessor, accessor0) {\n  if (type === LITERAL_SCALE_TYPE) {\n    return {\n      type: LITERAL_SCALE_TYPE,\n      domain: [],\n      range: [value],\n      distance: 0,\n      attr: attr,\n      baseValue: undefined,\n      isValue: true,\n      accessor: accessor,\n      accessor0: accessor0\n    };\n  }\n\n  if (typeof value === 'undefined') {\n    return null;\n  }\n\n  return {\n    type: CATEGORY_SCALE_TYPE,\n    range: [value],\n    domain: [],\n    distance: 0,\n    attr: attr,\n    baseValue: undefined,\n    isValue: true,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n/**\r\n * Create a regular scale object for a further use from the existing parameters.\r\n * @param {Array} domain - Domain.\r\n * @param {Array} range - Range.\r\n * @param {string} type - Type.\r\n * @param {number} distance - Distance.\r\n * @param {string} attr - Attribute.\r\n * @param {number} baseValue - Base value.\r\n * @param {function} accessor - Attribute accesor\r\n * @param {function} accessor0 - Attribute accesor for potential naught value\r\n * @returns {Object} Scale object.\r\n * @private\r\n */\n\n\nfunction _createScaleObjectForFunction(_ref) {\n  var domain = _ref.domain,\n      range = _ref.range,\n      type = _ref.type,\n      distance = _ref.distance,\n      attr = _ref.attr,\n      baseValue = _ref.baseValue,\n      accessor = _ref.accessor,\n      accessor0 = _ref.accessor0;\n  return {\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    isValue: false,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n/**\r\n * Get scale object from props. E. g. object like {xRange, xDomain, xDistance,\r\n * xType} is transformed into {range, domain, distance, type}.\r\n * @param {Object} props Props.\r\n * @param {string} attr Attribute.\r\n * @returns {*} Null or an object with the scale.\r\n * @private\r\n */\n\n\nfunction _collectScaleObjectFromProps(props, attr) {\n  var value = props[attr],\n      fallbackValue = props['_' + attr + 'Value'],\n      range = props[attr + 'Range'],\n      _props$ = props[attr + 'Distance'],\n      distance = _props$ === undefined ? 0 : _props$,\n      baseValue = props[attr + 'BaseValue'],\n      _props$2 = props[attr + 'Type'],\n      type = _props$2 === undefined ? LINEAR_SCALE_TYPE : _props$2,\n      noFallBack = props[attr + 'NoFallBack'],\n      _props$3 = props['get' + toTitleCase(attr)],\n      accessor = _props$3 === undefined ? function (d) {\n    return d[attr];\n  } : _props$3,\n      _props$4 = props['get' + toTitleCase(attr) + '0'],\n      accessor0 = _props$4 === undefined ? function (d) {\n    return d[attr + '0'];\n  } : _props$4;\n  var domain = props[attr + 'Domain']; // Return value-based scale if the value is assigned.\n\n  if (!noFallBack && typeof value !== 'undefined') {\n    return _createScaleObjectForValue(attr, value, props[attr + 'Type'], accessor, accessor0);\n  } // Pick up the domain from the properties and create a new one if it's not\n  // available.\n\n\n  if (typeof baseValue !== 'undefined') {\n    domain = addValueToArray(domain, baseValue);\n  } // Make sure that the minimum necessary properties exist.\n\n\n  if (!range || !domain || !domain.length) {\n    // Try to use the fallback value if it is available.\n    return _createScaleObjectForValue(attr, fallbackValue, props[attr + 'Type'], accessor, accessor0);\n  }\n\n  return _createScaleObjectForFunction({\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    accessor: accessor,\n    accessor0: accessor0\n  });\n}\n/**\r\n * Compute left domain adjustment for the given values.\r\n * @param {Array} values Array of values.\r\n * @returns {number} Domain adjustment.\r\n * @private\r\n */\n\n\nfunction _computeLeftDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[1] - values[0]) / 2;\n  }\n\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n\n  return 0;\n}\n/**\r\n * Compute right domain adjustment for the given values.\r\n * @param {Array} values Array of values.\r\n * @returns {number} Domain adjustment.\r\n * @private\r\n */\n\n\nfunction _computeRightDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[values.length - 1] - values[values.length - 2]) / 2;\n  }\n\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n\n  return 0;\n}\n/**\r\n * Compute distance for the given values.\r\n * @param {Array} values Array of values.\r\n * @param {Array} domain Domain.\r\n * @param {number} bestDistIndex Index of a best distance found.\r\n * @param {function} scaleFn Scale function.\r\n * @returns {number} Domain adjustment.\r\n * @private\r\n */\n\n\nfunction _computeScaleDistance(values, domain, bestDistIndex, scaleFn) {\n  if (values.length > 1) {\n    // Avoid zero indexes.\n    var i = Math.max(bestDistIndex, 1);\n    return Math.abs(scaleFn(values[i]) - scaleFn(values[i - 1]));\n  }\n\n  if (values.length === 1) {\n    return Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  }\n\n  return 0;\n}\n/**\r\n * Normilize array of values with a single value.\r\n * @param {Array} arr Array of data.\r\n * @param {Array} values Array of values.\r\n * @param {string} attr Attribute.\r\n * @param {string} type Type.\r\n * @private\r\n */\n\n\nfunction _normalizeValues(data, values, accessor0, type) {\n  if (type === TIME_SCALE_TYPE && values.length === 1) {\n    var attr0 = accessor0(data[0]);\n    return [attr0].concat(_toConsumableArray(values));\n  }\n\n  return values;\n}\n/**\r\n * Get the distance, the smallest and the largest value of the domain.\r\n * @param {Array} data Array of data for the single series.\r\n * @param {Object} scaleObject Scale object.\r\n * @returns {{domain0: number, domainN: number, distance: number}} Result.\r\n * @private\r\n */\n\n\nexport function _getScaleDistanceAndAdjustedDomain(data, scaleObject) {\n  var domain = scaleObject.domain,\n      type = scaleObject.type,\n      accessor = scaleObject.accessor,\n      accessor0 = scaleObject.accessor0;\n  var uniqueValues = getUniquePropertyValues(data, accessor); // Fix time scale if a data has only one value.\n\n  var values = _normalizeValues(data, uniqueValues, accessor0, type);\n\n  var index = _getSmallestDistanceIndex(values, scaleObject);\n\n  var adjustedDomain = [].concat(domain);\n  adjustedDomain[0] -= _computeLeftDomainAdjustment(values);\n  adjustedDomain[domain.length - 1] += _computeRightDomainAdjustment(values); // Fix log scale if it's too small.\n\n  if (type === LOG_SCALE_TYPE && domain[0] <= 0) {\n    adjustedDomain[0] = Math.min(domain[1] / 10, 1);\n  }\n\n  var adjustedScaleFn = getScaleFnFromScaleObject(_extends({}, scaleObject, {\n    domain: adjustedDomain\n  }));\n\n  var distance = _computeScaleDistance(values, adjustedDomain, index, adjustedScaleFn);\n\n  return {\n    domain0: adjustedDomain[0],\n    domainN: adjustedDomain[adjustedDomain.length - 1],\n    distance: distance\n  };\n}\n/**\r\n * Returns true if scale adjustments are possible for a given scale.\r\n * @param {Object} props Props.\r\n * @param {Object} scaleObject Scale object.\r\n * @returns {boolean} True if scale adjustments possible.\r\n * @private\r\n */\n\nfunction _isScaleAdjustmentPossible(props, scaleObject) {\n  var attr = scaleObject.attr;\n  var _props$_adjustBy = props._adjustBy,\n      adjustBy = _props$_adjustBy === undefined ? [] : _props$_adjustBy,\n      _props$_adjustWhat = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat === undefined ? [] : _props$_adjustWhat; // The scale cannot be adjusted if there's no attributes to adjust, no\n  // suitable values\n\n  return adjustWhat.length && adjustBy.length && adjustBy.indexOf(attr) !== -1;\n}\n/**\r\n * Adjust continuous scales (e.g. 'linear', 'log' and 'time') by adding the\r\n * space from the left and right of them and by computing the best distance.\r\n * @param {Object} props Props.\r\n * @param {Object} scaleObject Scale object.\r\n * @returns {*} Scale object with adjustments.\r\n * @private\r\n */\n\n\nfunction _adjustContinuousScale(props, scaleObject) {\n  var allSeriesData = props._allData,\n      _props$_adjustWhat2 = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat2 === undefined ? [] : _props$_adjustWhat2; // Assign the initial values.\n\n  var domainLength = scaleObject.domain.length;\n  var domain = scaleObject.domain;\n  var scaleDomain0 = domain[0];\n  var scaleDomainN = domain[domainLength - 1];\n  var scaleDistance = scaleObject.distance; // Find the smallest left position of the domain, the largest right position\n  // of the domain and the best distance for them.\n\n  allSeriesData.forEach(function (data, index) {\n    if (adjustWhat.indexOf(index) === -1) {\n      return;\n    }\n\n    if (data && data.length) {\n      var _getScaleDistanceAndA = _getScaleDistanceAndAdjustedDomain(data, scaleObject),\n          domain0 = _getScaleDistanceAndA.domain0,\n          domainN = _getScaleDistanceAndA.domainN,\n          distance = _getScaleDistanceAndA.distance;\n\n      scaleDomain0 = Math.min(scaleDomain0, domain0);\n      scaleDomainN = Math.max(scaleDomainN, domainN);\n      scaleDistance = Math.max(scaleDistance, distance);\n    }\n  });\n  scaleObject.domain = [scaleDomain0].concat(_toConsumableArray(domain.slice(1, -1)), [scaleDomainN]);\n  scaleObject.distance = scaleDistance;\n  return scaleObject;\n}\n/**\r\n * Get an adjusted scale. Suitable for 'category' and 'ordinal' scales.\r\n * @param {Object} scaleObject Scale object.\r\n * @returns {*} Scale object with adjustments.\r\n * @private\r\n */\n\n\nexport function _adjustCategoricalScale(scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var domain = scaleObject.domain,\n      range = scaleObject.range;\n\n  if (domain.length > 1) {\n    scaleObject.distance = Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  } else {\n    scaleObject.distance = Math.abs(range[1] - range[0]);\n  }\n\n  return scaleObject;\n}\n/**\r\n * Retrieve a scale object or a value from the properties passed.\r\n * @param {Object} props Object of props.\r\n * @param {string} attr Attribute.\r\n * @returns {*} Scale object, value or null.\r\n */\n\nexport function getScaleObjectFromProps(props, attr) {\n  // Create the initial scale object.\n  var scaleObject = _collectScaleObjectFromProps(props, attr);\n\n  if (!scaleObject) {\n    return null;\n  } // Make sure if it's possible to add space to the scale object. If not,\n  // return the object immediately.\n\n\n  if (!_isScaleAdjustmentPossible(props, scaleObject)) {\n    return scaleObject;\n  }\n\n  var type = scaleObject.type; // Depending on what type the scale is, apply different adjustments. Distances\n  // for the ordinal and category scales are even, equal domains cannot be\n  // adjusted.\n\n  if (type === ORDINAL_SCALE_TYPE || type === CATEGORY_SCALE_TYPE) {\n    return _adjustCategoricalScale(scaleObject);\n  }\n\n  return _adjustContinuousScale(props, scaleObject);\n}\n/**\r\n * Get d3 scale for a given prop.\r\n * @param {Object} props Props.\r\n * @param {string} attr Attribute.\r\n * @returns {function} d3 scale function.\r\n */\n\nexport function getAttributeScale(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  return getScaleFnFromScaleObject(scaleObject);\n}\n/**\r\n * Get the value of `attr` from the object.\r\n * @param {Object} d - data Object.\r\n * @param {Function} accessor - accessor function.\r\n * @returns {*} Value of the point.\r\n * @private\r\n */\n\nfunction _getAttrValue(d, accessor) {\n  return accessor(d.data ? d.data : d);\n}\n\nfunction _isDefined(value) {\n  return typeof value !== 'undefined';\n}\n/*\r\n * Adds a percentage of padding to a given domain\r\n * @param {Array} domain X or Y domain to pad.\r\n * @param {Number} padding Percentage of padding to add to domain\r\n * @returns {Array} Padded Domain\r\n */\n\n\nfunction _padDomain(domain, padding) {\n  if (!domain) {\n    return domain;\n  }\n\n  if (isNaN(parseFloat(domain[0])) || isNaN(parseFloat(domain[1]))) {\n    return domain;\n  }\n\n  var _domain = _slicedToArray(domain, 2),\n      min = _domain[0],\n      max = _domain[1];\n\n  var domainPadding = (max - min) * (padding * 0.01);\n  return [min - domainPadding, max + domainPadding];\n}\n/**\r\n * Get prop functor (either a value or a function) for a given attribute.\r\n * @param {Object} props Series props.\r\n * @param {Function} accessor - Property accessor.\r\n * @returns {*} Function or value.\r\n */\n\n\nexport function getAttributeFunctor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n\n  if (scaleObject) {\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      return scaleFn(_getAttrValue(d, scaleObject.accessor));\n    };\n  }\n\n  return null;\n}\n/**\r\n * Get the functor which extracts value form [attr]0 property. Use baseValue if\r\n * no attr0 property for a given object is defined. Fall back to domain[0] if no\r\n * base value is available.\r\n * @param {Object} props Object of props.\r\n * @param {string} attr Attribute name.\r\n * @returns {*} Function which returns value or null if no values available.\r\n */\n\nexport function getAttr0Functor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n\n  if (scaleObject) {\n    var domain = scaleObject.domain;\n    var _scaleObject$baseValu = scaleObject.baseValue,\n        baseValue = _scaleObject$baseValu === undefined ? domain[0] : _scaleObject$baseValu;\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      var value = _getAttrValue(d, scaleObject.accessor0);\n\n      return scaleFn(_isDefined(value) ? value : baseValue);\n    };\n  }\n\n  return null;\n}\n/**\r\n * Tries to get the string|number value of the attr and falls back to\r\n * a fallback property in case if the value is a scale.\r\n * @param {Object} props Series props.\r\n * @param {string} attr Property name.\r\n * @returns {*} Function or value.\r\n */\n\nexport function getAttributeValue(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n\n  if (scaleObject) {\n    if (!scaleObject.isValue && props['_' + attr + 'Value'] === undefined) {\n      warning('[React-vis] Cannot use data defined ' + attr + ' for this ' + 'series type. Using fallback value instead.');\n    }\n\n    return props['_' + attr + 'Value'] || scaleObject.range[0];\n  }\n\n  return null;\n}\n/**\r\n * Get prop types by the attribute.\r\n * @param {string} attr Attribute.\r\n * @returns {Object} Object of xDomain, xRange, xType, xDistance and _xValue,\r\n * where x is an attribute passed to the function.\r\n */\n\nexport function getScalePropTypesByAttribute(attr) {\n  var _ref2;\n\n  return _ref2 = {}, _defineProperty(_ref2, '_' + attr + 'Value', PropTypes.any), _defineProperty(_ref2, attr + 'Domain', PropTypes.array), _defineProperty(_ref2, 'get' + toTitleCase(attr), PropTypes.func), _defineProperty(_ref2, 'get' + toTitleCase(attr) + '0', PropTypes.func), _defineProperty(_ref2, attr + 'Range', PropTypes.array), _defineProperty(_ref2, attr + 'Type', PropTypes.oneOf(Object.keys(SCALE_FUNCTIONS))), _defineProperty(_ref2, attr + 'Distance', PropTypes.number), _defineProperty(_ref2, attr + 'BaseValue', PropTypes.any), _ref2;\n}\n/**\r\n * Extract the list of scale properties from the entire props object.\r\n * @param {Object} props Props.\r\n * @param {Array<String>} attributes Array of attributes for the given\r\n * components (for instance, `['x', 'y', 'color']`).\r\n * @returns {Object} Collected props.\r\n */\n\nexport function extractScalePropsFromProps(props, attributes) {\n  var result = {};\n  Object.keys(props).forEach(function (key) {\n    // this filtering is critical for extracting the correct accessors!\n    var attr = attributes.find(function (a) {\n      // width\n      var isPlainSet = key.indexOf(a) === 0; // Ex: _data\n\n      var isUnderscoreSet = key.indexOf('_' + a) === 0; // EX: getX\n\n      var usesGet = key.indexOf('get' + toTitleCase(a)) === 0;\n      return isPlainSet || isUnderscoreSet || usesGet;\n    });\n\n    if (!attr) {\n      return;\n    }\n\n    result[key] = props[key];\n  });\n  return result;\n}\n/**\r\n * Extract the missing scale props from the given data and return them as\r\n * an object.\r\n * @param {Object} props Props.\r\n * @param {Array} data Array of all data.\r\n * @param {Array<String>} attributes Array of attributes for the given\r\n * components (for instance, `['x', 'y', 'color']`).\r\n * @returns {Object} Collected props.\r\n */\n\nexport function getMissingScaleProps(props, data, attributes) {\n  var result = {}; // Make sure that the domain is set pad it if specified\n\n  attributes.forEach(function (attr) {\n    if (!props['get' + toTitleCase(attr)]) {\n      result['get' + toTitleCase(attr)] = function (d) {\n        return d[attr];\n      };\n    }\n\n    if (!props['get' + toTitleCase(attr) + '0']) {\n      result['get' + toTitleCase(attr) + '0'] = function (d) {\n        return d[attr + '0'];\n      };\n    }\n\n    if (!props[attr + 'Domain']) {\n      result[attr + 'Domain'] = getDomainByAccessor(data, props['get' + toTitleCase(attr)] || result['get' + toTitleCase(attr)], props['get' + toTitleCase(attr) + '0'] || result['get' + toTitleCase(attr) + '0'], props[attr + 'Type']);\n\n      if (props[attr + 'Padding']) {\n        result[attr + 'Domain'] = _padDomain(result[attr + 'Domain'], props[attr + 'Padding']);\n      }\n    }\n  });\n  return result;\n}\n/**\r\n * Return a d3 scale that returns the literal value that was given to it\r\n * @returns {function} literal scale.\r\n */\n\nexport function literalScale(defaultValue) {\n  function scale(d) {\n    if (d === undefined) {\n      return defaultValue;\n    }\n\n    return d;\n  }\n\n  function response() {\n    return scale;\n  }\n\n  scale.domain = response;\n  scale.range = response;\n  scale.unknown = response;\n  scale.copy = response;\n  return scale;\n}\nexport function getFontColorFromBackground(background) {\n  if (background) {\n    return hsl(background).l > 0.57 ? '#222' : '#fff';\n  }\n\n  return null;\n}\n/**\r\n * Creates fallback values for series from scales defined at XYPlot level.\r\n * @param {Object} props Props of the XYPlot object.\r\n * @param {Array<Object>} children Array of components, children of XYPlot\r\n * @returns {Array<Object>} Collected props.\r\n */\n\nexport function getXYPlotValues(props, children) {\n  var XYPlotScales = XYPLOT_ATTR.reduce(function (prev, attr) {\n    var domain = props[attr + 'Domain'],\n        range = props[attr + 'Range'],\n        type = props[attr + 'Type'];\n\n    if (domain && range && type) {\n      return _extends({}, prev, _defineProperty({}, attr, SCALE_FUNCTIONS[type]().domain(domain).range(range)));\n    }\n\n    return prev;\n  }, {});\n  return children.map(function (child) {\n    return XYPLOT_ATTR.reduce(function (prev, attr) {\n      if (child.props && child.props[attr] !== undefined) {\n        var scaleInput = child.props[attr];\n        var scale = XYPlotScales[attr];\n        var fallbackValue = scale ? scale(scaleInput) : scaleInput;\n        return _extends({}, prev, _defineProperty({}, '_' + attr + 'Value', fallbackValue));\n      }\n\n      return prev;\n    }, {});\n  });\n}\nvar OPTIONAL_SCALE_PROPS = ['Padding'];\nvar OPTIONAL_SCALE_PROPS_REGS = OPTIONAL_SCALE_PROPS.map(function (str) {\n  return new RegExp(str + '$', 'i');\n});\n/**\r\n * Get the list of optional scale-related settings for XYPlot\r\n * mostly just used to find padding properties\r\n * @param {Object} props Object of props.\r\n * @returns {Object} Optional Props.\r\n * @private\r\n */\n\nexport function getOptionalScaleProps(props) {\n  return Object.keys(props).reduce(function (acc, prop) {\n    var propIsNotOptional = OPTIONAL_SCALE_PROPS_REGS.every(function (reg) {\n      return !prop.match(reg);\n    });\n\n    if (propIsNotOptional) {\n      return acc;\n    }\n\n    acc[prop] = props[prop];\n    return acc;\n  }, {});\n}\nexport default {\n  extractScalePropsFromProps: extractScalePropsFromProps,\n  getAttributeScale: getAttributeScale,\n  getAttributeFunctor: getAttributeFunctor,\n  getAttr0Functor: getAttr0Functor,\n  getAttributeValue: getAttributeValue,\n  getDomainByAccessor: getDomainByAccessor,\n  getFontColorFromBackground: getFontColorFromBackground,\n  getMissingScaleProps: getMissingScaleProps,\n  getOptionalScaleProps: getOptionalScaleProps,\n  getScaleObjectFromProps: getScaleObjectFromProps,\n  getScalePropTypesByAttribute: getScalePropTypesByAttribute,\n  getXYPlotValues: getXYPlotValues,\n  literalScale: literalScale\n};","map":{"version":3,"sources":["C:/Users/thero/OneDrive/Documents/factory-management/factory-management/factory-managment-frontend/node_modules/react-vis/es/utils/scales-utils.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","err","Array","isArray","TypeError","_SCALE_FUNCTIONS","_toConsumableArray","arr2","from","_defineProperty","obj","defineProperty","enumerable","configurable","writable","scaleLinear","scalePoint","scaleOrdinal","scaleLog","scaleTime","scaleUtc","extent","set","hsl","PropTypes","warning","getUniquePropertyValues","addValueToArray","LINEAR_SCALE_TYPE","ORDINAL_SCALE_TYPE","CATEGORY_SCALE_TYPE","LITERAL_SCALE_TYPE","LOG_SCALE_TYPE","TIME_SCALE_TYPE","TIME_UTC_SCALE_TYPE","SCALE_FUNCTIONS","literalScale","XYPLOT_ATTR","toTitleCase","str","toUpperCase","slice","_getSmallestDistanceIndex","values","scaleObject","scaleFn","getScaleFnFromScaleObject","result","nextValue","currentValue","distance","Infinity","nextDistance","Math","abs","addInvertFunctionToOrdinalScaleObject","scale","invert","_scale$range","range","_scale$range2","lower","upper","start","min","stop","max","padding","step","domain","index","floor","type","modDomain","getDomainByAccessor","allData","accessor","accessor0","reduce","data","d","value0","_isDefined","_createScaleObjectForValue","attr","baseValue","isValue","_createScaleObjectForFunction","_ref","_collectScaleObjectFromProps","props","fallbackValue","_props$","_props$2","noFallBack","_props$3","_props$4","_computeLeftDomainAdjustment","_computeRightDomainAdjustment","_computeScaleDistance","bestDistIndex","_normalizeValues","attr0","concat","_getScaleDistanceAndAdjustedDomain","uniqueValues","adjustedDomain","adjustedScaleFn","domain0","domainN","_isScaleAdjustmentPossible","_props$_adjustBy","_adjustBy","adjustBy","_props$_adjustWhat","_adjustWhat","adjustWhat","indexOf","_adjustContinuousScale","allSeriesData","_allData","_props$_adjustWhat2","domainLength","scaleDomain0","scaleDomainN","scaleDistance","forEach","_getScaleDistanceAndA","_adjustCategoricalScale","getScaleObjectFromProps","getAttributeScale","_getAttrValue","_padDomain","isNaN","parseFloat","_domain","domainPadding","getAttributeFunctor","getAttr0Functor","_scaleObject$baseValu","getAttributeValue","getScalePropTypesByAttribute","_ref2","any","array","func","oneOf","keys","number","extractScalePropsFromProps","attributes","find","a","isPlainSet","isUnderscoreSet","usesGet","getMissingScaleProps","defaultValue","response","unknown","copy","getFontColorFromBackground","background","l","getXYPlotValues","children","XYPlotScales","prev","map","child","scaleInput","OPTIONAL_SCALE_PROPS","OPTIONAL_SCALE_PROPS_REGS","RegExp","getOptionalScaleProps","acc","prop","propIsNotOptional","every","reg","match"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\r\n\r\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\r\n\r\nvar _SCALE_FUNCTIONS;\r\n\r\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\n// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE.\r\n\r\nimport { scaleLinear, scalePoint, scaleOrdinal, scaleLog, scaleTime, scaleUtc } from 'd3-scale';\r\nimport { extent } from 'd3-array';\r\nimport { set } from 'd3-collection';\r\nimport { hsl } from 'd3-color';\r\n\r\nimport PropTypes from 'prop-types';\r\n\r\nimport { warning } from './react-utils';\r\nimport { getUniquePropertyValues, addValueToArray } from './data-utils';\r\n\r\n/**\r\n * Linear scale name.\r\n * @type {string}\r\n * @const\r\n */\r\nvar LINEAR_SCALE_TYPE = 'linear';\r\n\r\n/**\r\n * Ordinal scale name.\r\n * @type {string}\r\n * @const\r\n */\r\nvar ORDINAL_SCALE_TYPE = 'ordinal';\r\n\r\n/**\r\n * Category scale.\r\n * @type {string}\r\n * @const\r\n */\r\nvar CATEGORY_SCALE_TYPE = 'category';\r\n\r\n/**\r\n * Literal scale.\r\n * Differs slightly from d3's identity scale in that it does not coerce value\r\n * into numbers, it simply returns exactly what you give it\r\n * @type {string}\r\n * @const\r\n */\r\nvar LITERAL_SCALE_TYPE = 'literal';\r\n\r\n/**\r\n * Log scale name.\r\n * @type {string}\r\n * @const\r\n */\r\nvar LOG_SCALE_TYPE = 'log';\r\n\r\n/**\r\n * Time scale name.\r\n * @type {string}\r\n * @const\r\n */\r\nvar TIME_SCALE_TYPE = 'time';\r\n\r\n/**\r\n * Time UTC scale name.\r\n * @type {string}\r\n * @const\r\n */\r\nvar TIME_UTC_SCALE_TYPE = 'time-utc';\r\n\r\n/**\r\n * Scale functions that are supported in the library.\r\n * @type {Object}\r\n * @const\r\n */\r\nvar SCALE_FUNCTIONS = (_SCALE_FUNCTIONS = {}, _defineProperty(_SCALE_FUNCTIONS, LINEAR_SCALE_TYPE, scaleLinear), _defineProperty(_SCALE_FUNCTIONS, ORDINAL_SCALE_TYPE, scalePoint), _defineProperty(_SCALE_FUNCTIONS, CATEGORY_SCALE_TYPE, scaleOrdinal), _defineProperty(_SCALE_FUNCTIONS, LITERAL_SCALE_TYPE, literalScale), _defineProperty(_SCALE_FUNCTIONS, LOG_SCALE_TYPE, scaleLog), _defineProperty(_SCALE_FUNCTIONS, TIME_SCALE_TYPE, scaleTime), _defineProperty(_SCALE_FUNCTIONS, TIME_UTC_SCALE_TYPE, scaleUtc), _SCALE_FUNCTIONS);\r\n\r\n/**\r\n * Attrs for which a scale can be set up at XYPlot level\r\n * @type {Array}\r\n * @const\r\n */\r\n\r\nvar XYPLOT_ATTR = ['color', 'fill', 'opacity', 'stroke'];\r\n\r\n/**\r\n * Title case a given string\r\n * @param {String} str Array of values.\r\n * @returns {String} titlecased string\r\n */\r\nfunction toTitleCase(str) {\r\n  return '' + str[0].toUpperCase() + str.slice(1);\r\n}\r\n\r\n/**\r\n * Find the smallest distance between the values on a given scale and return\r\n * the index of the element, where the smallest distance was found.\r\n * It returns the first occurrence of i where\r\n * `scale(value[i]) - scale(value[i - 1])` is minimal\r\n * @param {Array} values Array of values.\r\n * @param {Object} scaleObject Scale object.\r\n * @returns {number} Index of an element where the smallest distance was found.\r\n * @private\r\n */\r\nexport function _getSmallestDistanceIndex(values, scaleObject) {\r\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\r\n  var result = 0;\r\n  if (scaleFn) {\r\n    var nextValue = void 0;\r\n    var currentValue = scaleFn(values[0]);\r\n    var distance = Infinity;\r\n    var nextDistance = void 0;\r\n\r\n    for (var i = 1; i < values.length; i++) {\r\n      nextValue = scaleFn(values[i]);\r\n      nextDistance = Math.abs(nextValue - currentValue);\r\n      if (nextDistance < distance) {\r\n        distance = nextDistance;\r\n        result = i;\r\n      }\r\n      currentValue = nextValue;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * This is a workaround for issue that ordinal scale\r\n * does not have invert method implemented in d3-scale.\r\n * @param {Object} Ordinal d3-scale object.\r\n * @returns {void}\r\n * @private\r\n */\r\n\r\nfunction addInvertFunctionToOrdinalScaleObject(scale) {\r\n  if (scale.invert) {\r\n    return;\r\n  }\r\n\r\n  scale.invert = function invert(value) {\r\n    var _scale$range = scale.range(),\r\n        _scale$range2 = _slicedToArray(_scale$range, 2),\r\n        lower = _scale$range2[0],\r\n        upper = _scale$range2[1];\r\n\r\n    var start = Math.min(lower, upper);\r\n    var stop = Math.max(lower, upper);\r\n\r\n    if (value < start + scale.padding() * scale.step()) {\r\n      return scale.domain()[0];\r\n    }\r\n\r\n    if (value > stop - scale.padding() * scale.step()) {\r\n      return scale.domain()[scale.domain().length - 1];\r\n    }\r\n\r\n    var index = Math.floor((value - start - scale.padding() * scale.step()) / scale.step());\r\n    return scale.domain()[index];\r\n  };\r\n}\r\n\r\n/**\r\n * Crate a scale function from the scale object.\r\n * @param {Object} scaleObject Scale object.\r\n - scaleObject.domain {Array}\r\n - scaleObject.range {Array}\r\n - scaleObject.type {string}\r\n - scaleObject.attr {string}\r\n * @returns {*} Scale function.\r\n * @private\r\n */\r\nexport function getScaleFnFromScaleObject(scaleObject) {\r\n  if (!scaleObject) {\r\n    return null;\r\n  }\r\n  var type = scaleObject.type,\r\n      domain = scaleObject.domain,\r\n      range = scaleObject.range;\r\n\r\n  var modDomain = domain[0] === domain[1] ? domain[0] === 0 ? [-1, 0] : [-domain[0], domain[0]] : domain;\r\n  if (type === LITERAL_SCALE_TYPE) {\r\n    return literalScale(range[0]);\r\n  }\r\n  var scale = SCALE_FUNCTIONS[type]().domain(modDomain).range(range);\r\n  if (type === ORDINAL_SCALE_TYPE) {\r\n    scale.padding(0.5);\r\n    addInvertFunctionToOrdinalScaleObject(scale);\r\n  }\r\n  return scale;\r\n}\r\n\r\n/**\r\n * Get the domain from the array of data.\r\n * @param {Array} allData All data.\r\n * @param {function} accessor - accessor for main value.\r\n * @param {function} accessor0 - accessor for the naught value.\r\n * @param {string} type Scale type.\r\n * @returns {Array} Domain.\r\n * @private\r\n */\r\nexport function getDomainByAccessor(allData, accessor, accessor0, type) {\r\n  var domain = void 0;\r\n\r\n  // Collect both attr and available attr0 values from the array of data.\r\n  var values = allData.reduce(function (data, d) {\r\n    var value = accessor(d);\r\n    var value0 = accessor0(d);\r\n    if (_isDefined(value)) {\r\n      data.push(value);\r\n    }\r\n    if (_isDefined(value0)) {\r\n      data.push(value0);\r\n    }\r\n    return data;\r\n  }, []);\r\n\r\n  if (!values.length) {\r\n    return [];\r\n  }\r\n\r\n  // Create proper domain depending on the type of the scale.\r\n  if (type !== ORDINAL_SCALE_TYPE && type !== CATEGORY_SCALE_TYPE) {\r\n    domain = extent(values);\r\n  } else {\r\n    domain = set(values).values();\r\n  }\r\n  return domain;\r\n}\r\n\r\n/**\r\n * Create custom scale object from the value. When the scale is created from\r\n * this object, it should return the same value all time.\r\n * @param {string} attr Attribute.\r\n * @param {*} value Value.\r\n * @param {string} type - the type of scale being used\r\n * @param {function} accessor - the accessor function\r\n * @param {function} accessor0 - the accessor function for the potential naught value\r\n * @returns {Object} Custom scale object.\r\n * @private\r\n */\r\nfunction _createScaleObjectForValue(attr, value, type, accessor, accessor0) {\r\n  if (type === LITERAL_SCALE_TYPE) {\r\n    return {\r\n      type: LITERAL_SCALE_TYPE,\r\n      domain: [],\r\n      range: [value],\r\n      distance: 0,\r\n      attr: attr,\r\n      baseValue: undefined,\r\n      isValue: true,\r\n      accessor: accessor,\r\n      accessor0: accessor0\r\n    };\r\n  }\r\n  if (typeof value === 'undefined') {\r\n    return null;\r\n  }\r\n  return {\r\n    type: CATEGORY_SCALE_TYPE,\r\n    range: [value],\r\n    domain: [],\r\n    distance: 0,\r\n    attr: attr,\r\n    baseValue: undefined,\r\n    isValue: true,\r\n    accessor: accessor,\r\n    accessor0: accessor0\r\n  };\r\n}\r\n\r\n/**\r\n * Create a regular scale object for a further use from the existing parameters.\r\n * @param {Array} domain - Domain.\r\n * @param {Array} range - Range.\r\n * @param {string} type - Type.\r\n * @param {number} distance - Distance.\r\n * @param {string} attr - Attribute.\r\n * @param {number} baseValue - Base value.\r\n * @param {function} accessor - Attribute accesor\r\n * @param {function} accessor0 - Attribute accesor for potential naught value\r\n * @returns {Object} Scale object.\r\n * @private\r\n */\r\nfunction _createScaleObjectForFunction(_ref) {\r\n  var domain = _ref.domain,\r\n      range = _ref.range,\r\n      type = _ref.type,\r\n      distance = _ref.distance,\r\n      attr = _ref.attr,\r\n      baseValue = _ref.baseValue,\r\n      accessor = _ref.accessor,\r\n      accessor0 = _ref.accessor0;\r\n\r\n  return {\r\n    domain: domain,\r\n    range: range,\r\n    type: type,\r\n    distance: distance,\r\n    attr: attr,\r\n    baseValue: baseValue,\r\n    isValue: false,\r\n    accessor: accessor,\r\n    accessor0: accessor0\r\n  };\r\n}\r\n\r\n/**\r\n * Get scale object from props. E. g. object like {xRange, xDomain, xDistance,\r\n * xType} is transformed into {range, domain, distance, type}.\r\n * @param {Object} props Props.\r\n * @param {string} attr Attribute.\r\n * @returns {*} Null or an object with the scale.\r\n * @private\r\n */\r\nfunction _collectScaleObjectFromProps(props, attr) {\r\n  var value = props[attr],\r\n      fallbackValue = props['_' + attr + 'Value'],\r\n      range = props[attr + 'Range'],\r\n      _props$ = props[attr + 'Distance'],\r\n      distance = _props$ === undefined ? 0 : _props$,\r\n      baseValue = props[attr + 'BaseValue'],\r\n      _props$2 = props[attr + 'Type'],\r\n      type = _props$2 === undefined ? LINEAR_SCALE_TYPE : _props$2,\r\n      noFallBack = props[attr + 'NoFallBack'],\r\n      _props$3 = props['get' + toTitleCase(attr)],\r\n      accessor = _props$3 === undefined ? function (d) {\r\n    return d[attr];\r\n  } : _props$3,\r\n      _props$4 = props['get' + toTitleCase(attr) + '0'],\r\n      accessor0 = _props$4 === undefined ? function (d) {\r\n    return d[attr + '0'];\r\n  } : _props$4;\r\n  var domain = props[attr + 'Domain'];\r\n  // Return value-based scale if the value is assigned.\r\n\r\n  if (!noFallBack && typeof value !== 'undefined') {\r\n    return _createScaleObjectForValue(attr, value, props[attr + 'Type'], accessor, accessor0);\r\n  }\r\n  // Pick up the domain from the properties and create a new one if it's not\r\n  // available.\r\n  if (typeof baseValue !== 'undefined') {\r\n    domain = addValueToArray(domain, baseValue);\r\n  }\r\n\r\n  // Make sure that the minimum necessary properties exist.\r\n  if (!range || !domain || !domain.length) {\r\n    // Try to use the fallback value if it is available.\r\n    return _createScaleObjectForValue(attr, fallbackValue, props[attr + 'Type'], accessor, accessor0);\r\n  }\r\n\r\n  return _createScaleObjectForFunction({\r\n    domain: domain,\r\n    range: range,\r\n    type: type,\r\n    distance: distance,\r\n    attr: attr,\r\n    baseValue: baseValue,\r\n    accessor: accessor,\r\n    accessor0: accessor0\r\n  });\r\n}\r\n\r\n/**\r\n * Compute left domain adjustment for the given values.\r\n * @param {Array} values Array of values.\r\n * @returns {number} Domain adjustment.\r\n * @private\r\n */\r\nfunction _computeLeftDomainAdjustment(values) {\r\n  if (values.length > 1) {\r\n    return (values[1] - values[0]) / 2;\r\n  }\r\n  if (values.length === 1) {\r\n    return values[0] - 0.5;\r\n  }\r\n  return 0;\r\n}\r\n\r\n/**\r\n * Compute right domain adjustment for the given values.\r\n * @param {Array} values Array of values.\r\n * @returns {number} Domain adjustment.\r\n * @private\r\n */\r\nfunction _computeRightDomainAdjustment(values) {\r\n  if (values.length > 1) {\r\n    return (values[values.length - 1] - values[values.length - 2]) / 2;\r\n  }\r\n  if (values.length === 1) {\r\n    return values[0] - 0.5;\r\n  }\r\n  return 0;\r\n}\r\n\r\n/**\r\n * Compute distance for the given values.\r\n * @param {Array} values Array of values.\r\n * @param {Array} domain Domain.\r\n * @param {number} bestDistIndex Index of a best distance found.\r\n * @param {function} scaleFn Scale function.\r\n * @returns {number} Domain adjustment.\r\n * @private\r\n */\r\nfunction _computeScaleDistance(values, domain, bestDistIndex, scaleFn) {\r\n  if (values.length > 1) {\r\n    // Avoid zero indexes.\r\n    var i = Math.max(bestDistIndex, 1);\r\n    return Math.abs(scaleFn(values[i]) - scaleFn(values[i - 1]));\r\n  }\r\n  if (values.length === 1) {\r\n    return Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\r\n  }\r\n  return 0;\r\n}\r\n\r\n/**\r\n * Normilize array of values with a single value.\r\n * @param {Array} arr Array of data.\r\n * @param {Array} values Array of values.\r\n * @param {string} attr Attribute.\r\n * @param {string} type Type.\r\n * @private\r\n */\r\nfunction _normalizeValues(data, values, accessor0, type) {\r\n  if (type === TIME_SCALE_TYPE && values.length === 1) {\r\n    var attr0 = accessor0(data[0]);\r\n\r\n    return [attr0].concat(_toConsumableArray(values));\r\n  }\r\n\r\n  return values;\r\n}\r\n\r\n/**\r\n * Get the distance, the smallest and the largest value of the domain.\r\n * @param {Array} data Array of data for the single series.\r\n * @param {Object} scaleObject Scale object.\r\n * @returns {{domain0: number, domainN: number, distance: number}} Result.\r\n * @private\r\n */\r\nexport function _getScaleDistanceAndAdjustedDomain(data, scaleObject) {\r\n  var domain = scaleObject.domain,\r\n      type = scaleObject.type,\r\n      accessor = scaleObject.accessor,\r\n      accessor0 = scaleObject.accessor0;\r\n\r\n\r\n  var uniqueValues = getUniquePropertyValues(data, accessor);\r\n\r\n  // Fix time scale if a data has only one value.\r\n  var values = _normalizeValues(data, uniqueValues, accessor0, type);\r\n  var index = _getSmallestDistanceIndex(values, scaleObject);\r\n\r\n  var adjustedDomain = [].concat(domain);\r\n\r\n  adjustedDomain[0] -= _computeLeftDomainAdjustment(values);\r\n  adjustedDomain[domain.length - 1] += _computeRightDomainAdjustment(values);\r\n  // Fix log scale if it's too small.\r\n  if (type === LOG_SCALE_TYPE && domain[0] <= 0) {\r\n    adjustedDomain[0] = Math.min(domain[1] / 10, 1);\r\n  }\r\n\r\n  var adjustedScaleFn = getScaleFnFromScaleObject(_extends({}, scaleObject, {\r\n    domain: adjustedDomain\r\n  }));\r\n\r\n  var distance = _computeScaleDistance(values, adjustedDomain, index, adjustedScaleFn);\r\n\r\n  return {\r\n    domain0: adjustedDomain[0],\r\n    domainN: adjustedDomain[adjustedDomain.length - 1],\r\n    distance: distance\r\n  };\r\n}\r\n\r\n/**\r\n * Returns true if scale adjustments are possible for a given scale.\r\n * @param {Object} props Props.\r\n * @param {Object} scaleObject Scale object.\r\n * @returns {boolean} True if scale adjustments possible.\r\n * @private\r\n */\r\nfunction _isScaleAdjustmentPossible(props, scaleObject) {\r\n  var attr = scaleObject.attr;\r\n  var _props$_adjustBy = props._adjustBy,\r\n      adjustBy = _props$_adjustBy === undefined ? [] : _props$_adjustBy,\r\n      _props$_adjustWhat = props._adjustWhat,\r\n      adjustWhat = _props$_adjustWhat === undefined ? [] : _props$_adjustWhat;\r\n\r\n  // The scale cannot be adjusted if there's no attributes to adjust, no\r\n  // suitable values\r\n\r\n  return adjustWhat.length && adjustBy.length && adjustBy.indexOf(attr) !== -1;\r\n}\r\n\r\n/**\r\n * Adjust continuous scales (e.g. 'linear', 'log' and 'time') by adding the\r\n * space from the left and right of them and by computing the best distance.\r\n * @param {Object} props Props.\r\n * @param {Object} scaleObject Scale object.\r\n * @returns {*} Scale object with adjustments.\r\n * @private\r\n */\r\nfunction _adjustContinuousScale(props, scaleObject) {\r\n  var allSeriesData = props._allData,\r\n      _props$_adjustWhat2 = props._adjustWhat,\r\n      adjustWhat = _props$_adjustWhat2 === undefined ? [] : _props$_adjustWhat2;\r\n\r\n  // Assign the initial values.\r\n\r\n  var domainLength = scaleObject.domain.length;\r\n  var domain = scaleObject.domain;\r\n\r\n  var scaleDomain0 = domain[0];\r\n  var scaleDomainN = domain[domainLength - 1];\r\n  var scaleDistance = scaleObject.distance;\r\n\r\n  // Find the smallest left position of the domain, the largest right position\r\n  // of the domain and the best distance for them.\r\n  allSeriesData.forEach(function (data, index) {\r\n    if (adjustWhat.indexOf(index) === -1) {\r\n      return;\r\n    }\r\n    if (data && data.length) {\r\n      var _getScaleDistanceAndA = _getScaleDistanceAndAdjustedDomain(data, scaleObject),\r\n          domain0 = _getScaleDistanceAndA.domain0,\r\n          domainN = _getScaleDistanceAndA.domainN,\r\n          distance = _getScaleDistanceAndA.distance;\r\n\r\n      scaleDomain0 = Math.min(scaleDomain0, domain0);\r\n      scaleDomainN = Math.max(scaleDomainN, domainN);\r\n      scaleDistance = Math.max(scaleDistance, distance);\r\n    }\r\n  });\r\n\r\n  scaleObject.domain = [scaleDomain0].concat(_toConsumableArray(domain.slice(1, -1)), [scaleDomainN]);\r\n\r\n  scaleObject.distance = scaleDistance;\r\n\r\n  return scaleObject;\r\n}\r\n\r\n/**\r\n * Get an adjusted scale. Suitable for 'category' and 'ordinal' scales.\r\n * @param {Object} scaleObject Scale object.\r\n * @returns {*} Scale object with adjustments.\r\n * @private\r\n */\r\nexport function _adjustCategoricalScale(scaleObject) {\r\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\r\n  var domain = scaleObject.domain,\r\n      range = scaleObject.range;\r\n\r\n  if (domain.length > 1) {\r\n    scaleObject.distance = Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\r\n  } else {\r\n    scaleObject.distance = Math.abs(range[1] - range[0]);\r\n  }\r\n\r\n  return scaleObject;\r\n}\r\n\r\n/**\r\n * Retrieve a scale object or a value from the properties passed.\r\n * @param {Object} props Object of props.\r\n * @param {string} attr Attribute.\r\n * @returns {*} Scale object, value or null.\r\n */\r\nexport function getScaleObjectFromProps(props, attr) {\r\n  // Create the initial scale object.\r\n  var scaleObject = _collectScaleObjectFromProps(props, attr);\r\n  if (!scaleObject) {\r\n    return null;\r\n  }\r\n\r\n  // Make sure if it's possible to add space to the scale object. If not,\r\n  // return the object immediately.\r\n  if (!_isScaleAdjustmentPossible(props, scaleObject)) {\r\n    return scaleObject;\r\n  }\r\n\r\n  var type = scaleObject.type;\r\n  // Depending on what type the scale is, apply different adjustments. Distances\r\n  // for the ordinal and category scales are even, equal domains cannot be\r\n  // adjusted.\r\n\r\n  if (type === ORDINAL_SCALE_TYPE || type === CATEGORY_SCALE_TYPE) {\r\n    return _adjustCategoricalScale(scaleObject);\r\n  }\r\n  return _adjustContinuousScale(props, scaleObject);\r\n}\r\n\r\n/**\r\n * Get d3 scale for a given prop.\r\n * @param {Object} props Props.\r\n * @param {string} attr Attribute.\r\n * @returns {function} d3 scale function.\r\n */\r\nexport function getAttributeScale(props, attr) {\r\n  var scaleObject = getScaleObjectFromProps(props, attr);\r\n  return getScaleFnFromScaleObject(scaleObject);\r\n}\r\n\r\n/**\r\n * Get the value of `attr` from the object.\r\n * @param {Object} d - data Object.\r\n * @param {Function} accessor - accessor function.\r\n * @returns {*} Value of the point.\r\n * @private\r\n */\r\nfunction _getAttrValue(d, accessor) {\r\n  return accessor(d.data ? d.data : d);\r\n}\r\n\r\nfunction _isDefined(value) {\r\n  return typeof value !== 'undefined';\r\n}\r\n\r\n/*\r\n * Adds a percentage of padding to a given domain\r\n * @param {Array} domain X or Y domain to pad.\r\n * @param {Number} padding Percentage of padding to add to domain\r\n * @returns {Array} Padded Domain\r\n */\r\nfunction _padDomain(domain, padding) {\r\n  if (!domain) {\r\n    return domain;\r\n  }\r\n  if (isNaN(parseFloat(domain[0])) || isNaN(parseFloat(domain[1]))) {\r\n    return domain;\r\n  }\r\n\r\n  var _domain = _slicedToArray(domain, 2),\r\n      min = _domain[0],\r\n      max = _domain[1];\r\n\r\n  var domainPadding = (max - min) * (padding * 0.01);\r\n  return [min - domainPadding, max + domainPadding];\r\n}\r\n\r\n/**\r\n * Get prop functor (either a value or a function) for a given attribute.\r\n * @param {Object} props Series props.\r\n * @param {Function} accessor - Property accessor.\r\n * @returns {*} Function or value.\r\n */\r\nexport function getAttributeFunctor(props, attr) {\r\n  var scaleObject = getScaleObjectFromProps(props, attr);\r\n  if (scaleObject) {\r\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\r\n    return function (d) {\r\n      return scaleFn(_getAttrValue(d, scaleObject.accessor));\r\n    };\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Get the functor which extracts value form [attr]0 property. Use baseValue if\r\n * no attr0 property for a given object is defined. Fall back to domain[0] if no\r\n * base value is available.\r\n * @param {Object} props Object of props.\r\n * @param {string} attr Attribute name.\r\n * @returns {*} Function which returns value or null if no values available.\r\n */\r\nexport function getAttr0Functor(props, attr) {\r\n  var scaleObject = getScaleObjectFromProps(props, attr);\r\n  if (scaleObject) {\r\n    var domain = scaleObject.domain;\r\n    var _scaleObject$baseValu = scaleObject.baseValue,\r\n        baseValue = _scaleObject$baseValu === undefined ? domain[0] : _scaleObject$baseValu;\r\n\r\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\r\n    return function (d) {\r\n      var value = _getAttrValue(d, scaleObject.accessor0);\r\n      return scaleFn(_isDefined(value) ? value : baseValue);\r\n    };\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Tries to get the string|number value of the attr and falls back to\r\n * a fallback property in case if the value is a scale.\r\n * @param {Object} props Series props.\r\n * @param {string} attr Property name.\r\n * @returns {*} Function or value.\r\n */\r\nexport function getAttributeValue(props, attr) {\r\n  var scaleObject = getScaleObjectFromProps(props, attr);\r\n  if (scaleObject) {\r\n    if (!scaleObject.isValue && props['_' + attr + 'Value'] === undefined) {\r\n      warning('[React-vis] Cannot use data defined ' + attr + ' for this ' + 'series type. Using fallback value instead.');\r\n    }\r\n    return props['_' + attr + 'Value'] || scaleObject.range[0];\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Get prop types by the attribute.\r\n * @param {string} attr Attribute.\r\n * @returns {Object} Object of xDomain, xRange, xType, xDistance and _xValue,\r\n * where x is an attribute passed to the function.\r\n */\r\nexport function getScalePropTypesByAttribute(attr) {\r\n  var _ref2;\r\n\r\n  return _ref2 = {}, _defineProperty(_ref2, '_' + attr + 'Value', PropTypes.any), _defineProperty(_ref2, attr + 'Domain', PropTypes.array), _defineProperty(_ref2, 'get' + toTitleCase(attr), PropTypes.func), _defineProperty(_ref2, 'get' + toTitleCase(attr) + '0', PropTypes.func), _defineProperty(_ref2, attr + 'Range', PropTypes.array), _defineProperty(_ref2, attr + 'Type', PropTypes.oneOf(Object.keys(SCALE_FUNCTIONS))), _defineProperty(_ref2, attr + 'Distance', PropTypes.number), _defineProperty(_ref2, attr + 'BaseValue', PropTypes.any), _ref2;\r\n}\r\n\r\n/**\r\n * Extract the list of scale properties from the entire props object.\r\n * @param {Object} props Props.\r\n * @param {Array<String>} attributes Array of attributes for the given\r\n * components (for instance, `['x', 'y', 'color']`).\r\n * @returns {Object} Collected props.\r\n */\r\nexport function extractScalePropsFromProps(props, attributes) {\r\n  var result = {};\r\n  Object.keys(props).forEach(function (key) {\r\n    // this filtering is critical for extracting the correct accessors!\r\n    var attr = attributes.find(function (a) {\r\n      // width\r\n      var isPlainSet = key.indexOf(a) === 0;\r\n      // Ex: _data\r\n      var isUnderscoreSet = key.indexOf('_' + a) === 0;\r\n      // EX: getX\r\n      var usesGet = key.indexOf('get' + toTitleCase(a)) === 0;\r\n      return isPlainSet || isUnderscoreSet || usesGet;\r\n    });\r\n    if (!attr) {\r\n      return;\r\n    }\r\n    result[key] = props[key];\r\n  });\r\n  return result;\r\n}\r\n\r\n/**\r\n * Extract the missing scale props from the given data and return them as\r\n * an object.\r\n * @param {Object} props Props.\r\n * @param {Array} data Array of all data.\r\n * @param {Array<String>} attributes Array of attributes for the given\r\n * components (for instance, `['x', 'y', 'color']`).\r\n * @returns {Object} Collected props.\r\n */\r\nexport function getMissingScaleProps(props, data, attributes) {\r\n  var result = {};\r\n  // Make sure that the domain is set pad it if specified\r\n  attributes.forEach(function (attr) {\r\n    if (!props['get' + toTitleCase(attr)]) {\r\n      result['get' + toTitleCase(attr)] = function (d) {\r\n        return d[attr];\r\n      };\r\n    }\r\n    if (!props['get' + toTitleCase(attr) + '0']) {\r\n      result['get' + toTitleCase(attr) + '0'] = function (d) {\r\n        return d[attr + '0'];\r\n      };\r\n    }\r\n    if (!props[attr + 'Domain']) {\r\n      result[attr + 'Domain'] = getDomainByAccessor(data, props['get' + toTitleCase(attr)] || result['get' + toTitleCase(attr)], props['get' + toTitleCase(attr) + '0'] || result['get' + toTitleCase(attr) + '0'], props[attr + 'Type']);\r\n      if (props[attr + 'Padding']) {\r\n        result[attr + 'Domain'] = _padDomain(result[attr + 'Domain'], props[attr + 'Padding']);\r\n      }\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Return a d3 scale that returns the literal value that was given to it\r\n * @returns {function} literal scale.\r\n */\r\nexport function literalScale(defaultValue) {\r\n  function scale(d) {\r\n    if (d === undefined) {\r\n      return defaultValue;\r\n    }\r\n    return d;\r\n  }\r\n\r\n  function response() {\r\n    return scale;\r\n  }\r\n\r\n  scale.domain = response;\r\n  scale.range = response;\r\n  scale.unknown = response;\r\n  scale.copy = response;\r\n\r\n  return scale;\r\n}\r\n\r\nexport function getFontColorFromBackground(background) {\r\n  if (background) {\r\n    return hsl(background).l > 0.57 ? '#222' : '#fff';\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Creates fallback values for series from scales defined at XYPlot level.\r\n * @param {Object} props Props of the XYPlot object.\r\n * @param {Array<Object>} children Array of components, children of XYPlot\r\n * @returns {Array<Object>} Collected props.\r\n */\r\n\r\nexport function getXYPlotValues(props, children) {\r\n  var XYPlotScales = XYPLOT_ATTR.reduce(function (prev, attr) {\r\n    var domain = props[attr + 'Domain'],\r\n        range = props[attr + 'Range'],\r\n        type = props[attr + 'Type'];\r\n\r\n\r\n    if (domain && range && type) {\r\n      return _extends({}, prev, _defineProperty({}, attr, SCALE_FUNCTIONS[type]().domain(domain).range(range)));\r\n    }\r\n    return prev;\r\n  }, {});\r\n\r\n  return children.map(function (child) {\r\n    return XYPLOT_ATTR.reduce(function (prev, attr) {\r\n      if (child.props && child.props[attr] !== undefined) {\r\n        var scaleInput = child.props[attr];\r\n        var scale = XYPlotScales[attr];\r\n        var fallbackValue = scale ? scale(scaleInput) : scaleInput;\r\n        return _extends({}, prev, _defineProperty({}, '_' + attr + 'Value', fallbackValue));\r\n      }\r\n      return prev;\r\n    }, {});\r\n  });\r\n}\r\n\r\nvar OPTIONAL_SCALE_PROPS = ['Padding'];\r\nvar OPTIONAL_SCALE_PROPS_REGS = OPTIONAL_SCALE_PROPS.map(function (str) {\r\n  return new RegExp(str + '$', 'i');\r\n});\r\n/**\r\n * Get the list of optional scale-related settings for XYPlot\r\n * mostly just used to find padding properties\r\n * @param {Object} props Object of props.\r\n * @returns {Object} Optional Props.\r\n * @private\r\n */\r\nexport function getOptionalScaleProps(props) {\r\n  return Object.keys(props).reduce(function (acc, prop) {\r\n    var propIsNotOptional = OPTIONAL_SCALE_PROPS_REGS.every(function (reg) {\r\n      return !prop.match(reg);\r\n    });\r\n    if (propIsNotOptional) {\r\n      return acc;\r\n    }\r\n    acc[prop] = props[prop];\r\n    return acc;\r\n  }, {});\r\n}\r\n\r\nexport default {\r\n  extractScalePropsFromProps: extractScalePropsFromProps,\r\n  getAttributeScale: getAttributeScale,\r\n  getAttributeFunctor: getAttributeFunctor,\r\n  getAttr0Functor: getAttr0Functor,\r\n  getAttributeValue: getAttributeValue,\r\n  getDomainByAccessor: getDomainByAccessor,\r\n  getFontColorFromBackground: getFontColorFromBackground,\r\n  getMissingScaleProps: getMissingScaleProps,\r\n  getOptionalScaleProps: getOptionalScaleProps,\r\n  getScaleObjectFromProps: getScaleObjectFromProps,\r\n  getScalePropTypesByAttribute: getScalePropTypesByAttribute,\r\n  getXYPlotValues: getXYPlotValues,\r\n  literalScale: literalScale\r\n};"]},"metadata":{},"sourceType":"module"}