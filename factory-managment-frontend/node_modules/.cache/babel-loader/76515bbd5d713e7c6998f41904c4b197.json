{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport React from 'react';\nimport AbstractSeries from '../plot/series/abstract-series';\nimport { DISCRETE_COLOR_RANGE, DEFAULT_OPACITY } from '../theme';\n/**\n * Check if the component is series or not.\n * @param {React.Component} child Component.\n * @returns {boolean} True if the child is series, false otherwise.\n */\n\nexport function isSeriesChild(child) {\n  var prototype = child.type.prototype;\n  return prototype instanceof AbstractSeries;\n}\n/**\n * Get all series from the 'children' object of the component.\n * @param {Object} children Children.\n * @returns {Array} Array of children.\n */\n\nexport function getSeriesChildren(children) {\n  return React.Children.toArray(children).filter(function (child) {\n    return child && isSeriesChild(child);\n  });\n}\n/**\n * Collect the map of repetitions of the series type for all children.\n * @param {Array} children Array of children.\n * @returns {{}} Map of repetitions where sameTypeTotal is the total amount and\n * sameTypeIndex is always 0.\n */\n\nfunction collectSeriesTypesInfo(children) {\n  var result = {};\n  children.filter(isSeriesChild).forEach(function (child) {\n    var displayName = child.type.displayName;\n    var cluster = child.props.cluster;\n\n    if (!result[displayName]) {\n      result[displayName] = {\n        sameTypeTotal: 0,\n        sameTypeIndex: 0,\n        clusters: new Set()\n      };\n    }\n\n    result[displayName].clusters.add(cluster);\n    result[displayName].sameTypeTotal++;\n  });\n  return result;\n}\n/**\n * Check series to see if it has angular data that needs to be converted\n * @param {Array} data - an array of objects to check\n * @returns {Boolean} whether or not this series contains polar configuration\n */\n\n\nfunction seriesHasAngleRadius() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  if (!data) {\n    return false;\n  }\n\n  return data.some(function (row) {\n    return row.radius && row.angle;\n  });\n}\n/**\n * Possibly convert polar coordinates to x/y for computing domain\n * @param {Array} data - an array of objects to check\n * @param {String} attr - the property being checked\n * @returns {Boolean} whether or not this series contains polar configuration\n */\n\n\nfunction prepareData(data) {\n  if (!seriesHasAngleRadius(data)) {\n    return data;\n  }\n\n  return data.map(function (row) {\n    return _extends({}, row, {\n      x: row.radius * Math.cos(row.angle),\n      y: row.radius * Math.sin(row.angle)\n    });\n  });\n}\n/**\n * Collect the stacked data for all children in use. If the children don't have\n * the data (e.g. the child is invalid series or something else), then the child\n * is skipped.\n * Each next value of attr is equal to the previous value plus the difference\n * between attr0 and attr.\n * @param {Array} children Array of children.\n * @param {string} attr Attribute to stack by.\n * @returns {Array} New array of children for the series.\n */\n\n\nexport function getStackedData(children, attr) {\n  var areSomeSeriesStacked = children.some(function (series) {\n    return series && series.props.stack;\n  }); // It stores the last segment position added to each bar, separated by cluster.\n\n  var latestAttrPositions = {};\n  return children.reduce(function (accumulator, series, seriesIndex) {\n    // Skip the children that are not series (e.g. don't have any data).\n    if (!series) {\n      accumulator.push(null);\n      return accumulator;\n    }\n\n    var seriesType = series.type.displayName;\n    var _series$props = series.props,\n        data = _series$props.data,\n        _series$props$cluster = _series$props.cluster,\n        cluster = _series$props$cluster === undefined ? 'default' : _series$props$cluster,\n        stack = _series$props.stack;\n    var preppedData = prepareData(data, attr);\n\n    if (!attr || !preppedData || !preppedData.length || areSomeSeriesStacked && !stack) {\n      accumulator.push(preppedData);\n      return accumulator;\n    }\n\n    var attr0 = attr + '0';\n    var baseAttr = attr === 'y' ? 'x' : 'y';\n    accumulator.push(preppedData.map(function (d, dIndex) {\n      var _extends2, _latestAttrPositions$2;\n\n      if (!latestAttrPositions[cluster]) {\n        latestAttrPositions[cluster] = {};\n      }\n\n      if (!latestAttrPositions[cluster][seriesType]) {\n        latestAttrPositions[cluster][seriesType] = {};\n      }\n\n      var prevD = latestAttrPositions[cluster][seriesType][d[baseAttr]]; // It is the first segment of a bar.\n\n      if (!prevD) {\n        var _latestAttrPositions$;\n\n        latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$ = {}, _defineProperty(_latestAttrPositions$, attr0, d[attr0]), _defineProperty(_latestAttrPositions$, attr, d[attr]), _latestAttrPositions$);\n        return _extends({}, d);\n      } // Calculate the position of the next segment in a bar.\n\n\n      var nextD = _extends({}, d, (_extends2 = {}, _defineProperty(_extends2, attr0, prevD[attr]), _defineProperty(_extends2, attr, prevD[attr] + d[attr] - (d[attr0] || 0)), _extends2));\n\n      latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$2 = {}, _defineProperty(_latestAttrPositions$2, attr0, nextD[attr0]), _defineProperty(_latestAttrPositions$2, attr, nextD[attr]), _latestAttrPositions$2);\n      return nextD;\n    }));\n    return accumulator;\n  }, []);\n}\n/**\n * Get the list of series props for a child.\n * @param {Array} children Array of all children.\n * @returns {Array} Array of series props for each child. If a child is not a\n * series, than it's undefined.\n */\n\nexport function getSeriesPropsFromChildren(children) {\n  var result = [];\n  var seriesTypesInfo = collectSeriesTypesInfo(children);\n  var seriesIndex = 0;\n  var _opacityValue = DEFAULT_OPACITY;\n  children.forEach(function (child) {\n    var props = void 0;\n\n    if (isSeriesChild(child)) {\n      var seriesTypeInfo = seriesTypesInfo[child.type.displayName];\n      var _colorValue = DISCRETE_COLOR_RANGE[seriesIndex % DISCRETE_COLOR_RANGE.length];\n      props = _extends({}, seriesTypeInfo, {\n        seriesIndex: seriesIndex,\n        _colorValue: _colorValue,\n        _opacityValue: _opacityValue\n      });\n      seriesTypeInfo.sameTypeIndex++;\n      seriesIndex++;\n\n      if (child.props.cluster) {\n        props.cluster = child.props.cluster; // Using Array.from() so we can use .indexOf\n\n        props.clusters = Array.from(seriesTypeInfo.clusters);\n        props.sameTypeTotal = props.clusters.length;\n        props.sameTypeIndex = props.clusters.indexOf(child.props.cluster);\n      }\n    }\n\n    result.push(props);\n  });\n  return result;\n}\n/**\n * Find the max radius value from the nodes to be rendered after they have been\n * transformed into an array\n * @param {Array} data - the tree data after it has been broken into a iterable\n * it is an array of objects!\n * @returns {number} the maximum value in coordinates for the radial variable\n */\n\nexport function getRadialDomain(data) {\n  return data.reduce(function (res, row) {\n    return Math.max(row.radius, res);\n  }, 0);\n}\nexport var ANIMATED_SERIES_PROPS = ['xRange', 'xDomain', 'x', 'yRange', 'yDomain', 'y', 'colorRange', 'colorDomain', 'color', 'opacityRange', 'opacityDomain', 'opacity', 'strokeRange', 'strokeDomain', 'stroke', 'fillRange', 'fillDomain', 'fill', 'width', 'height', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'data', 'angleDomain', 'angleRange', 'angle', 'radiusDomain', 'radiusRange', 'radius', 'innerRadiusDomain', 'innerRadiusRange', 'innerRadius'];\nexport function getStackParams(props) {\n  var _stackBy = props._stackBy,\n      valuePosAttr = props.valuePosAttr,\n      cluster = props.cluster;\n  var _props$sameTypeTotal = props.sameTypeTotal,\n      sameTypeTotal = _props$sameTypeTotal === undefined ? 1 : _props$sameTypeTotal,\n      _props$sameTypeIndex = props.sameTypeIndex,\n      sameTypeIndex = _props$sameTypeIndex === undefined ? 0 : _props$sameTypeIndex; // If bars are stacked, but not clustering, override `sameTypeTotal` and\n  // `sameTypeIndex` such that bars are stacked and not staggered.\n\n  if (_stackBy === valuePosAttr && !cluster) {\n    sameTypeTotal = 1;\n    sameTypeIndex = 0;\n  }\n\n  return {\n    sameTypeTotal: sameTypeTotal,\n    sameTypeIndex: sameTypeIndex\n  };\n}","map":{"version":3,"sources":["/home/prabath/Documents/SLiit Projects/factory-management/factory-managment-frontend/node_modules/react-vis/es/utils/series-utils.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_defineProperty","obj","value","defineProperty","enumerable","configurable","writable","React","AbstractSeries","DISCRETE_COLOR_RANGE","DEFAULT_OPACITY","isSeriesChild","child","type","getSeriesChildren","children","Children","toArray","filter","collectSeriesTypesInfo","result","forEach","displayName","cluster","props","sameTypeTotal","sameTypeIndex","clusters","Set","add","seriesHasAngleRadius","data","undefined","some","row","radius","angle","prepareData","map","x","Math","cos","y","sin","getStackedData","attr","areSomeSeriesStacked","series","stack","latestAttrPositions","reduce","accumulator","seriesIndex","push","seriesType","_series$props","_series$props$cluster","preppedData","attr0","baseAttr","d","dIndex","_extends2","_latestAttrPositions$2","prevD","_latestAttrPositions$","nextD","getSeriesPropsFromChildren","seriesTypesInfo","_opacityValue","seriesTypeInfo","_colorValue","Array","from","indexOf","getRadialDomain","res","max","ANIMATED_SERIES_PROPS","getStackParams","_stackBy","valuePosAttr","_props$sameTypeTotal","_props$sameTypeIndex"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport React from 'react';\n\nimport AbstractSeries from '../plot/series/abstract-series';\nimport { DISCRETE_COLOR_RANGE, DEFAULT_OPACITY } from '../theme';\n\n/**\n * Check if the component is series or not.\n * @param {React.Component} child Component.\n * @returns {boolean} True if the child is series, false otherwise.\n */\nexport function isSeriesChild(child) {\n  var prototype = child.type.prototype;\n\n  return prototype instanceof AbstractSeries;\n}\n\n/**\n * Get all series from the 'children' object of the component.\n * @param {Object} children Children.\n * @returns {Array} Array of children.\n */\nexport function getSeriesChildren(children) {\n  return React.Children.toArray(children).filter(function (child) {\n    return child && isSeriesChild(child);\n  });\n}\n\n/**\n * Collect the map of repetitions of the series type for all children.\n * @param {Array} children Array of children.\n * @returns {{}} Map of repetitions where sameTypeTotal is the total amount and\n * sameTypeIndex is always 0.\n */\nfunction collectSeriesTypesInfo(children) {\n  var result = {};\n  children.filter(isSeriesChild).forEach(function (child) {\n    var displayName = child.type.displayName;\n    var cluster = child.props.cluster;\n\n    if (!result[displayName]) {\n      result[displayName] = {\n        sameTypeTotal: 0,\n        sameTypeIndex: 0,\n        clusters: new Set()\n      };\n    }\n    result[displayName].clusters.add(cluster);\n    result[displayName].sameTypeTotal++;\n  });\n  return result;\n}\n\n/**\n * Check series to see if it has angular data that needs to be converted\n * @param {Array} data - an array of objects to check\n * @returns {Boolean} whether or not this series contains polar configuration\n */\nfunction seriesHasAngleRadius() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  if (!data) {\n    return false;\n  }\n  return data.some(function (row) {\n    return row.radius && row.angle;\n  });\n}\n\n/**\n * Possibly convert polar coordinates to x/y for computing domain\n * @param {Array} data - an array of objects to check\n * @param {String} attr - the property being checked\n * @returns {Boolean} whether or not this series contains polar configuration\n */\nfunction prepareData(data) {\n  if (!seriesHasAngleRadius(data)) {\n    return data;\n  }\n\n  return data.map(function (row) {\n    return _extends({}, row, {\n      x: row.radius * Math.cos(row.angle),\n      y: row.radius * Math.sin(row.angle)\n    });\n  });\n}\n\n/**\n * Collect the stacked data for all children in use. If the children don't have\n * the data (e.g. the child is invalid series or something else), then the child\n * is skipped.\n * Each next value of attr is equal to the previous value plus the difference\n * between attr0 and attr.\n * @param {Array} children Array of children.\n * @param {string} attr Attribute to stack by.\n * @returns {Array} New array of children for the series.\n */\nexport function getStackedData(children, attr) {\n  var areSomeSeriesStacked = children.some(function (series) {\n    return series && series.props.stack;\n  });\n  // It stores the last segment position added to each bar, separated by cluster.\n  var latestAttrPositions = {};\n\n  return children.reduce(function (accumulator, series, seriesIndex) {\n    // Skip the children that are not series (e.g. don't have any data).\n    if (!series) {\n      accumulator.push(null);\n      return accumulator;\n    }\n    var seriesType = series.type.displayName;\n\n    var _series$props = series.props,\n        data = _series$props.data,\n        _series$props$cluster = _series$props.cluster,\n        cluster = _series$props$cluster === undefined ? 'default' : _series$props$cluster,\n        stack = _series$props.stack;\n\n    var preppedData = prepareData(data, attr);\n\n    if (!attr || !preppedData || !preppedData.length || areSomeSeriesStacked && !stack) {\n      accumulator.push(preppedData);\n      return accumulator;\n    }\n\n    var attr0 = attr + '0';\n    var baseAttr = attr === 'y' ? 'x' : 'y';\n\n    accumulator.push(preppedData.map(function (d, dIndex) {\n      var _extends2, _latestAttrPositions$2;\n\n      if (!latestAttrPositions[cluster]) {\n        latestAttrPositions[cluster] = {};\n      }\n      if (!latestAttrPositions[cluster][seriesType]) {\n        latestAttrPositions[cluster][seriesType] = {};\n      }\n\n      var prevD = latestAttrPositions[cluster][seriesType][d[baseAttr]];\n      // It is the first segment of a bar.\n      if (!prevD) {\n        var _latestAttrPositions$;\n\n        latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$ = {}, _defineProperty(_latestAttrPositions$, attr0, d[attr0]), _defineProperty(_latestAttrPositions$, attr, d[attr]), _latestAttrPositions$);\n\n        return _extends({}, d);\n      }\n\n      // Calculate the position of the next segment in a bar.\n      var nextD = _extends({}, d, (_extends2 = {}, _defineProperty(_extends2, attr0, prevD[attr]), _defineProperty(_extends2, attr, prevD[attr] + d[attr] - (d[attr0] || 0)), _extends2));\n\n      latestAttrPositions[cluster][seriesType][d[baseAttr]] = (_latestAttrPositions$2 = {}, _defineProperty(_latestAttrPositions$2, attr0, nextD[attr0]), _defineProperty(_latestAttrPositions$2, attr, nextD[attr]), _latestAttrPositions$2);\n\n      return nextD;\n    }));\n\n    return accumulator;\n  }, []);\n}\n\n/**\n * Get the list of series props for a child.\n * @param {Array} children Array of all children.\n * @returns {Array} Array of series props for each child. If a child is not a\n * series, than it's undefined.\n */\nexport function getSeriesPropsFromChildren(children) {\n  var result = [];\n  var seriesTypesInfo = collectSeriesTypesInfo(children);\n  var seriesIndex = 0;\n  var _opacityValue = DEFAULT_OPACITY;\n  children.forEach(function (child) {\n    var props = void 0;\n    if (isSeriesChild(child)) {\n      var seriesTypeInfo = seriesTypesInfo[child.type.displayName];\n      var _colorValue = DISCRETE_COLOR_RANGE[seriesIndex % DISCRETE_COLOR_RANGE.length];\n      props = _extends({}, seriesTypeInfo, {\n        seriesIndex: seriesIndex,\n        _colorValue: _colorValue,\n        _opacityValue: _opacityValue\n      });\n      seriesTypeInfo.sameTypeIndex++;\n      seriesIndex++;\n      if (child.props.cluster) {\n        props.cluster = child.props.cluster;\n        // Using Array.from() so we can use .indexOf\n        props.clusters = Array.from(seriesTypeInfo.clusters);\n        props.sameTypeTotal = props.clusters.length;\n        props.sameTypeIndex = props.clusters.indexOf(child.props.cluster);\n      }\n    }\n    result.push(props);\n  });\n  return result;\n}\n\n/**\n * Find the max radius value from the nodes to be rendered after they have been\n * transformed into an array\n * @param {Array} data - the tree data after it has been broken into a iterable\n * it is an array of objects!\n * @returns {number} the maximum value in coordinates for the radial variable\n */\nexport function getRadialDomain(data) {\n  return data.reduce(function (res, row) {\n    return Math.max(row.radius, res);\n  }, 0);\n}\n\nexport var ANIMATED_SERIES_PROPS = ['xRange', 'xDomain', 'x', 'yRange', 'yDomain', 'y', 'colorRange', 'colorDomain', 'color', 'opacityRange', 'opacityDomain', 'opacity', 'strokeRange', 'strokeDomain', 'stroke', 'fillRange', 'fillDomain', 'fill', 'width', 'height', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'data', 'angleDomain', 'angleRange', 'angle', 'radiusDomain', 'radiusRange', 'radius', 'innerRadiusDomain', 'innerRadiusRange', 'innerRadius'];\n\nexport function getStackParams(props) {\n  var _stackBy = props._stackBy,\n      valuePosAttr = props.valuePosAttr,\n      cluster = props.cluster;\n  var _props$sameTypeTotal = props.sameTypeTotal,\n      sameTypeTotal = _props$sameTypeTotal === undefined ? 1 : _props$sameTypeTotal,\n      _props$sameTypeIndex = props.sameTypeIndex,\n      sameTypeIndex = _props$sameTypeIndex === undefined ? 0 : _props$sameTypeIndex;\n\n  // If bars are stacked, but not clustering, override `sameTypeTotal` and\n  // `sameTypeIndex` such that bars are stacked and not staggered.\n\n  if (_stackBy === valuePosAttr && !cluster) {\n    sameTypeTotal = 1;\n    sameTypeIndex = 0;\n  }\n  return { sameTypeTotal: sameTypeTotal, sameTypeIndex: sameTypeIndex };\n}"]},"metadata":{},"sourceType":"module"}